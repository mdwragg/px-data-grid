<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../vaadin-grid/vaadin-grid.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-sorter.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-column-group.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-tree-toggle.html">
<link rel="import" href="../px-spinner/px-spinner.html">
<link rel="import" href="../px-modal/px-modal.html">
<link rel="import" href="../px-icon-set/px-icon.html"/>
<link rel="import" href="px-data-grid-column.html">
<link rel="import" href="px-auto-filter-field.html">
<link rel="import" href="px-data-grid-theme.html">
<link rel="import" href="px-data-grid-selection-column.html">
<link rel="import" href="px-data-grid-toggle-details-column.html">
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html"/>
<link rel="import" href="../px-moment-imports/px-moment-imports.html"/>

<link rel="import" href="px-data-grid-string-renderer.html">
<link rel="import" href="px-data-grid-date-renderer.html">
<link rel="import" href="px-data-grid-number-renderer.html">
<link rel="import" href="px-data-grid-cell-content-wrapper.html">
<link rel="import" href="px-data-grid-filter.html">
<link rel="import" href="px-data-grid-filters-modal.html">
<link rel="import" href="px-data-grid-filters-preview.html">
<link rel="import" href="px-data-grid-sorter.html">
<link rel="import" href="px-data-grid-action-column.html">
<link rel="import" href="px-data-grid-edit-column.html">

<link rel="import" href="px-data-grid-filterable-mixin.html">

<link rel="import" href="css/px-data-grid-styles.html">

<dom-module id="px-data-grid">
  <template>
    <style include="px-data-grid-styles"></style>

    <template is="dom-if" if="{{_showActionBar(autoFilter, hideActionMenu, filterable)}}">

      <div class="action-bar">
        <template is="dom-if" if="[[autoFilter]]">
          <px-auto-filter-field
            placeholder="[[localize('Search Table')]]"
            on-filter-change="_autoFilterChanged"
            value="{{_autoFilterValue}}"
          >
          </px-auto-filter-field>
        </template>

        <div class="action-bar__right">
          <template is="dom-if" if="[[filterable]]">
            <px-data-grid-filters-modal
              filters="{{_filters}}"
              columns="[[columns]]"
              localize="[[_boundedLocalize]]"
              offer-filter-saving="[[offerFilterSaving]]"
              initial-filter-state="[[_initialFilterState]]"
              compact-mode="[[compactAdvancedFilterDialog]]"
              string-comparators="[[stringComparators]]"
              number-comparators="[[numberComparators]]">
            </px-data-grid-filters-modal>
          </template>

          <template is="dom-if" if="[[!hideActionMenu]]">
            <px-dropdown
              multi
              hide-selected
              allow-outside-scroll
              display-value="[[localize('Actions')]]"
              items="[[_actionMenuContent]]"
              selected-values="[[_selectedActionItems]]"
              disable-clear
              on-px-dropdown-click="_actionClicked">
            </px-dropdown>
          </template>
        </div>

      </div>
    </template>

    <px-data-grid-filters-preview
      filters="[[_filters]]"
      columns="[[columns]]"
      localize="[[_boundedLocalize]]"
      on-trigger-filters-modal="_openAdvancedFilter">
    </px-data-grid-filters-preview>

    <vaadin-grid size="[[size]]"
                 data-provider="[[_currentDataProvider]]"
                 active-item="[[activeItem]]"
                 column-reordering-allowed="[[_isColumnReorderingAllowed(columnReorderingAllowed,_groupByColumn)]]"
                 expanded-items="[[expandedItems]]"
                 striped$="[[_isStriped(striped,_groupByColumn)]]"
                 selected-items="{{selectedItems}}"
                 multi-sort="[[multiSort]]"
                 item-id-path="{{itemIdPath}}"
                 page-size="{{pageSize}}"
                 auto-height$="[[_isAutoHeight(gridHeight)]]"
                 loading="{{_loading}}">

      <template is="dom-if" if="[[_isSelectable(selectionMode)]]" restamp>
        <px-data-grid-selection-column
          frozen
          auto-select
          hidden="[[hideSelectionColumn]]"
          multi-select="[[_isMultiSelect(selectionMode)]]"
          tree-grid="[[_groupByColumn]]"
          allow-sort-by-selection="[[allowSortBySelection]]"
        >
        </px-data-grid-selection-column>
      </template>

      <template is="dom-if" if="[[rowDetails]]" restamp>
        <px-data-grid-toggle-details-column frozen>
        </px-data-grid-toggle-details-column>
      </template>

      <template is="dom-repeat" items="[[columns]]" as="column" restamp>
        <px-data-grid-column
          name="[[column.name]]"
          path="[[column.path]]"
          hidden="[[column.hidden]]"
          localize="[[_boundedLocalize]]"
          type="[[column.type]]"
          frozen="[[_undefinedToFalse(column.frozen)]]"
          resizable="[[_checkColumnResizable(resizable, column.resizable)]]"
          mapped-object="[[column]]"
          width="[[_getColumnWidth(column)]]"
          flex-grow="[[_getColumnFlexGrow(column)]]"
          on-column-change="_onColumnUpdate"
          group-by-column-allowed="[[_groupByColumnAllowed(_hasLocalDataProvider, _expandableRows)]]"
          is-data-column="true">
          <template class="header">
            <px-data-grid-sorter path="[[_resolveColumnPath(column)]]">[[resolveColumnHeader(column)]]</px-data-grid-sorter>
          </template>

          <template>

            <dom-if if="[[_isGroupedByColumn(column, _groupByColumn)]]">
              <template>
                <vaadin-grid-tree-toggle leaf="[[!item.hasChildren]]" expanded="{{expanded}}" level="[[level]]">
                  <template is="dom-if" if="[[item.hasChildren]]">
                    <template is="dom-if" if="[[!expanded]]">
                      <px-icon icon="px-utl:chevron-right"></px-icon>
                    </template>
                    <template is="dom-if" if="[[expanded]]">
                      <px-icon icon="px-utl:chevron"></px-icon>
                    </template>
                  </template>
                  <px-data-grid-cell-content-wrapper
                    focus-target
                    cell-color="[[_resolveCellColor(item, column, _highlightEntities.*)]]"
                    item="{{item}}"
                    column="[[column]]"
                    localize="[[_boundedLocalize]]">
                  </px-data-grid-cell-content-wrapper>
                </vaadin-grid-tree-toggle>
              </template>
            </dom-if>

            <dom-if if="[[!_isGroupedByColumn(column, _groupByColumn)]]">
              <template>
                <px-data-grid-cell-content-wrapper
                  focus-target
                  cell-color="[[_resolveCellColor(item, column, _highlightEntities.*, _editingItem)]]"
                  item="{{item}}"
                  column="[[column]]"
                  localize="[[_boundedLocalize]]">
                </px-data-grid-cell-content-wrapper>
              </template>
            </dom-if>
          </template>
        </px-data-grid-column>
      </template>

      <vaadin-grid-column-group>
        <template is="dom-if" if="[[_offerEditColumn(editable)]]" restamp>
          <px-data-grid-edit-column
            editted-item="[[_editingItem]]"
            edit-mode="[[editable]]"
            edit="[[_boundedEditItem]]"
            cancel="[[_boundedCancelEdit]]">
          </px-data-grid-column>
        </template>

        <template is="dom-if" if="[[_offerActionColumn(editable, itemActions, _editingItem)]]" restamp>
          <px-data-grid-action-column
            item-actions="[[itemActions]]"
            editted-item="[[_editingItem]]"
            edit-mode="[[editable]]"
            save="[[_boundedSaveItem]]">
          </px-data-grid-column>
        </template>
      </vaadin-grid-column-group>
    </vaadin-grid>

    <px-spinner size="40" hidden$="[[_spinnerHidden]]"></px-spinner>
  </template>
  <script>
    {
      /**
       * `<px-data-grid>` - Predix UI component which defines a data grid.
       *
       * @mixes Predix.DataGridFilterableMixin
       */
      class DataGridElement extends Predix.DataGridFilterableMixin(
        Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element)
      ) {

        static get is() {
          return 'px-data-grid';
        }

        static get properties() {
          return {

            /**
             * Data for the table to display.
             *
             * Expected data format is a JSON array of objects. Each object in the array represents a row in the table.
             *
             * Each item in an object will be displayed as a separate column, unless px-data-table-columns are
             * defined to limit which columns are displayed.
             */
            tableData: {
              type: Array,
              notify: true
            },

            /**
             * If true, hides the column with checkboxes.
             */
            hideSelectionColumn: {
              type: Boolean,
              value: false
            },

            /**
             * An array that contains the selected items.
             */
            selectedItems: {
              type: Array,
              value: () => [],
              notify: true
            },

            /**
             * The total number of items
             */
            size: {
              type: Number,
              value: undefined
            },

            /**
             * Number of items fetched at a time from the dataprovider.
             */
            pageSize: {
              type: Number,
              value: undefined
            },

            /**
             * When `true`, user can sort by multiple columns
             */
            multiSort: {
              type: Boolean,
              value: false
            },

            /**
             * Current selection mode of grid. Accepts values 'none', 'single' and 'multi'.
             */
            selectionMode: {
              type: String,
              value: 'none',
              observer: '_selectionModeChanged'
            },

            /**
             * The item user has last interacted with. Turns to `null` after user deactivates
             * the item by re-interacting with the currently active item.
             */
            activeItem: {
              type: Object,
              notify: true,
              value: null
            },

            /**
             * When `true`, user can resize columns
             */
            resizable: {
              type: Boolean,
              value: false
            },

            /**
             * When `true`, user can edit data
             */
            editable: {
              type: Boolean,
              value: false
            },

            /**
             * Set to true to allow column reordering. Notice that some states will disable
             * reordering (eg. grouped by value).
             */
            columnReorderingAllowed: {
              type: Boolean,
              value: false
            },

            /**
             * An array containing references to expanded items.
             */
            expandedItems: {
              type: Array,
              value: []
            },

            /**
             * Set to true to enable a togglable row details container. This container
             * is hidden by default, but can be opened by clicking the chevron icon to left
             * of the row.
             */
            rowDetails: {
              type: Boolean,
              value: false,
              observer: '_onRowDetailsChange'
            },

            /**
             * Define if table action menu should be hidden.
             */
            hideActionMenu: {
              type: Boolean,
              value: false
            },

            /**
             * Sets the columns the grid should render. If no columns are passed, the grid
             * generates columns from the `tableData` passed in. Columns are rendered
             * in the same order as the array.
             *
             * Each column can have the following configurations. Only name and path
             * are required, all others are optional:
             *
             *   * `{string} id='column.path[column.type]'` - Unique identificator of the column.
             *     By default, px-data-grid will automatically generate it from `column.path` and `column.type`.
             *     There can't be 2 columns with the same id.
             *     Also, note, that `-any-` is reserved keyword for `id`, you should not use it.
             *
             *   * `{string} name` - Name, that is displayed in column header.
             *
             *   * `{string} path` - Column's path indicates a key, which is used to get data from data object.
             *
             *   * `{string} type=('string'|'number'|'date')` - Type of column.
             *     Influences on advanced filter's UI. Different selectors will be displayed for different types.
             *
             *   * `{string} renderer` - You can define your own renderer element to display and edit cell data in your own way.
             *     For more information, please check sample renderers, e.g. `px-data-grid-number-renderer`, `px-data-grid-date-renderer`.
             *
             *   * `{object} rendererConfig` - An arbitrary object that can be used to pass down options to the chosen renderer.
             *      See `px-data-grid-date-renderer` for an example of a renderer using this object for its four configurable properties
             *
             *   * `{array} dateRanges` - list of pre-defined date ranges, that will appear in advanced filter's
             *      dropdown when column.type is date. See format in `px-data-grid-column-demo`.
             *
             *   * `{number} minBound` - Used to define minimum bound of a number in advanced filter's slider.
             *     Note, that this property works with `column.type === 'number'` only.
             *
             *   * `{number} maxBound` - Used to define maximum bound of a number in advanced filter's slider.
             *     Note, that this property works with `column.type === 'number'` only.
             *     If both minBound and maxBound properties are defined, advanced filter will display slider instead of dropdown.
             *
             *   * `{boolean} hidden=false` - Indicates whether a column is hidden.
             *
             *   * `{boolean} frozen=false` - Indicates whether a column is frozen.
             *
             *   * `{boolean} required=false` - This property is used in renderers to validate data when user edits it.
             *
             *   * `{number} flexGrow=1` - Indicates whether a column should grow, equialent to the CSS flex-grow property.
             *
             * Example format for a single column with all configurations used:
             *
             * ```javascript
             * {
             *   id: 'first[string]',
             *   name: 'First Name',
             *   path: 'first',
             *   type: 'string',
             *   renderer: 'px-data-grid-string-renderer',
             *   rendererConfig: {
             *     customInfo: 'some info',
             *     customInfo2: 42
             *   },
             *   dateRanges: [
             *     {
             *       name: 'Last 7 days',
             *       getRange: () => {
             *         return {
             *           dateTo: window.moment().format(),
             *           dateFrom: window.moment().subtract(7, 'd').format()
             *         };
             *       }
             *     },
             *     {
             *       name: 'Fixed range',
             *       range: {
             *         dateTo: '1996-11-10',
             *         dateFrom: '1985-12-19'
             *       }
             *     }
             *   ],
             *   minBound: 1,
             *   maxBound: 10,
             *   hidden: false,
             *   frozen: false,
             *   required: false,
             *   flexGrow: 1
             * }
             * ```
             */
            columns: {
              type: Array,
              value: () => [],
              observer: '_columnsChanged'
            },

            /**
             * Copy of last columns value received, to be used with reset layout
             */
            _lastColumnsReceived: {
              type: Array,
              value: () => []
            },

            /**
             * Content of action menu
             */
            _actionMenuContent: {
              type: Array
            },

            /**
             * A valid IETF language tag as a string that `app-localize-behavior` will
             * use to localize this component.
             *
             * See https://github.com/PolymerElements/app-localize-behavior for API
             * documentation and more information.
             */
            language: {
              type: String,
              value: 'en'
            },

            /**
             * Use the key for localization if value for that language is missing.
             * Should always be true for Predix components.
             */
            useKeyIfMissing: {
              type: Boolean,
              value: true
            },

            /**
             * Library object of hardcoded strings used in this application.
             * Used by `app-localize-behavior` in conjunction with `language`.
             */
            resources: {
              type: Object,
              value: () => {
                // can also load these from external file as shown here:
                // https://www.polymer-project.org/2.0/toolbox/localize
                return {
                  'en': {
                    'Actions': 'Actions',
                    'Freeze column': 'Freeze Column',
                    'Unfreeze column': 'Unfreeze Column',
                    'Group by column': 'Group by Column',
                    'Ungroup': 'Ungroup',
                    'Hide column': 'Hide Column'
                  },
                  'fr': {
                    'Actions': 'Actions',
                    'Value is required': 'Pakollinen arvo'
                  },
                  'fi': {
                    'Actions': 'Toiminnot',
                    'Hide column': 'Piilota sarake'
                  }
                };
              }
            },

            /**
             * All custom table actions shown before columns. Array should contain objects
             * with name (String, shown to user) and id (String, given back in event).
             * When user selects these actions table-action event will be emitted, with id of
             * action at event.detail.id
             * ```
             * [
             *   {
             *     name: 'Export CSV',
             *     id: 'CSV'
             *   }
             *   {
             *     name: 'Export Excel',
             *     id: 'Excel'
             *   }
             * ]
             * ```
             */
            tableActions: {
              type: Array,
              value: []
            },

            /**
             * All custom item actions shown on the data rows. Array should contain objects
             * with name (String, shown to user) and id (String, given back in event).
             * When user selects these actions item-action event will be emitted, with id of
             * action at event.detail.id
             * ```
             * [
             *   {
             *     name: 'Add Row',
             *     id: 'add'
             *   }
             *   {
             *     name: 'Delete Row',
             *     id: 'delete'
             *   }
             * ]
             * ```
             */
            itemActions: {
              type: Array,
              value: []
            },

            /**
             * Function that provides items lazily. Receives arguments `params`, `callback`:
             *
             * `params.page` Requested page index
             *
             * `params.pageSize` Current page size
             *
             * `params.filters` Currently applied filters
             *
             * `params.sortOrders` Currently applied sorting orders
             *
             * `params.parentItem` When expandable table is used, and sublevel items
             * are requested, reference to parent item of the requested sublevel.
             * Otherwise `undefined`.
             *
             * `callback(items, size)` Callback function with arguments:
             *   - `items` Current page of items
             *   - `size` Total number of items. When tree sublevel items
             *     are requested, total number of items in the requested sublevel.
             *     Optional when tree is not used, required for tree.
             *
             * `<px-data-grid>` calls this function lazily, only when it needs more data
             * to be displayed.
             *
             * __Note that expanding the tree grid's item will trigger a call to `remoteDataProvider`.__
             *
             * __Also, note that when using function data providers, the total number of items
             * needs to be set manually. The total number of items can be returned
             * in the second argument of the data provider callback:__
             *
             * ```javascript
             * pxDataGrid.dataProvider = function(params, callback) {
             *   var url = 'https://api.example/data' +
             *       '?page=' + params.page +        // the requested page index
             *       '&per_page=' + params.pageSize; // number of items on the page
             *   var xhr = new XMLHttpRequest();
             *   xhr.onload = function() {
             *     var response = JSON.parse(xhr.responseText);
             *     callback(
             *       response.employees, // requested page of items
             *       response.totalSize  // total number of items
             *     );
             *   };
             *   xhr.open('GET', url, true);
             *   xhr.send();
             * };
             * ```
             *
             * __Alternatively, you can use the `size` property to set the total number of items:__
             *
             * ```javascript
             * pxDataGrid.size = 200; // The total number of items
             * pxDataGrid.dataProvider = function(params, callback) {
             *   var url = 'https://api.example/data' +
             *       '?page=' + params.page +        // the requested page index
             *       '&per_page=' + params.pageSize; // number of items on the page
             *   var xhr = new XMLHttpRequest();
             *   xhr.onload = function() {
             *     var response = JSON.parse(xhr.responseText);
             *     callback(response.employees);
             *   };
             *   xhr.open('GET', url, true);
             *   xhr.send();
             * };
             * ```
             */
            remoteDataProvider: {
              type: Function,
              observer: '_remoteDataProviderChanged'
            },

            _currentDataProvider: {
              type: Function
            },

            /**
             * If true, row-details template is provided and rows are expandable
             */
            _expandableRows: {
              type: Boolean,
              value: false
            },

            /**
             * If true, every other row in the table will appear with a background color to improve visual scanning.
             * When grouped by column striping will be disabled.
             */
            striped: {
              type: Boolean,
              value: false
            },

            /**
             * If true sets all columns to use ellipsis when text overflows the column,
             * enabling wrap mode while ellisis mode is enabled is an undefined state.
             */
            ellipsis: {
              type: Boolean,
              value: false,
              observer: '_ellipsisModeChanged'
            },

            /**
             * Shows if there is any pending request for remote data.
             */
            _loading: {
              type: Boolean,
              value: false,
              observer: '_loadingChanged'
            },

            _spinnerHidden: {
              type: Boolean,
              value: true
            },

            /**
             * How many milliseconds before loading spinner will be shown
             */
            loadingSpinnerDebounce: {
              type: Number,
              value: 500
            },

            /**
             * To enable automatic filtering change property to true
             */
            autoFilter: {
              type: Boolean,
              value: false
            },

            /**
             * Array of objects of conditions used to highlight specific columns.
             * Format:
             * ```javascript
             * {
             *   type: 'cell',
             *   condition: (cellContent, column, item) => { return cellContent == 'John Doe' },
             * },
             * {
             *   type: 'row',
             *   condition: (cellContent, item) => { return cellContent[0] == 'a' },
             *   color: '#a8a8a8'
             * },
             * {
             *   type: 'column',
             *   condition (column, item) => { return column.name == 'age' },
             *   color: 'pink'
             * }
             * ```
             */
            highlight: {
              type: Array,
              value: () => []
            },

            /**
             * Concatenated array from user's highlights and filter's
             */
            _highlightEntities: {
              type: Array,
              value: () => []
            },

            /**
             * When true data provider is local, when false external (remote) and
             * when undefined it defined yet.
             */
            _hasLocalDataProvider: {
              type: Boolean
            },

            /**
             * Default column width if not defined, eg. '100px'. Notice that with not
             * zero flex values this value behaves more as minimum width. See
             * defaultColumnFlexGrow property.
             */
            defaultColumnWidth: {
              type: String,
              value: '100px'
            },

            /**
             * Default column flex if not defined, eg. 1. Equialent to the CSS flex-grow
             * property.
             */
            defaultColumnFlexGrow: {
              type: Number,
              value: 1
            },

            _selectedActionItems: {
              type: Array,
              value: []
            },

            _groupByColumn: {
              type: Object,
              value: false
            },

            /**
             * Define height of grid. If 'auto' the height of grid will match with
             * match with number of rows in grid. Undefined value and 'default'
             * will use default height. Any other value (eg. '400px') is given as
             * CSS height value to the actual grid component inside px-data-grid.
             */
            gridHeight: {
              type: String,
              reflectToAttribute: true,
              observer: '_gridHeightChanged'
            },

            /**
             * Sets the px-grid to a mode where it and its content will flex to size.
             * By default the  px-data-grid will take 100% of the available height, this
             * can be changed by defining the css variable: --px-data-grid-height
             */
            flexToSize: {
              type: Boolean,
              value: false,
              reflectToAttribute: true
            },

            /**
             * Path to an item sub-property that identifies the item. This should be
             * defined in case of any editing, to allow grid to pair new version of
             * item with new. Path must point to unique identifier in data objects
             * that does not change (eg. 'id')
             */
            itemIdPath: {
              type: String
            },

            /**
             * If filter saving options should offered to end user. If save is
             * selected it will emit save-filters event.
             */
            offerFilterSaving: {
              type: Boolean,
              value: false
            },

            /**
             * If user is allowed to sort by selection
             */
            allowSortBySelection: {
              type: Boolean,
              value: false
            },

            /**
             * If enabled in multi selection and sort by selection mode any
             * changes to selection will cause instant re-sort.
             */
            instantSortWhenSelection: {
              type: Boolean,
              value: false
            },

            /* If true advanced filter dialog will be rendered in space saving
             * mode (eg. reuseable headers).
             */
            compactAdvancedFilterDialog: {
              type: Boolean,
              value: true
            },

            /**
             * What string comparators will be offered in advanced filtering. Valid options are
             * 'equals', 'contains', 'starts_with', 'ends_with' and 'wildcard'. If array is
             * undefined or empty, all options will be offered.
             */
            stringComparators: {
              type: Array
            },

            /**
             * What number comparators will be offered in advanced filtering. Valid options are
             * 'less_than', 'equals', 'not_equal',  'equal_or_greater_than',  'equal_or_less_than'
             * and 'greater_than'. If array is undefined or empty, all options will be offered.
             */
            numberComparators: {
              type: Array
            },

            /**
             * Stores item, that is currently in edit mode.
             */
            _editingItem: {
              type: Object,
              value: null,
              observer: '_editingItemObserver'
            },

            /**
             * Stores all renderer elements for item, that is currently in edit mode.
             */
            _editingRenderers: {
              type: Array,
              value: () => []
            },

            _boundedLocalize: Function,

            _autoFilterValue: {
              type: String
            }
          };
        }

        static get observers() {
          return [
            '_highlightsObserver(highlight, _filterHighlights, highlight.*, _filterHightlights.*)',
            '_localizeChanged(localize)',
            '_tableDataChanged(tableData, tableData.*, isAttached)',
            '_setColumnId(columns, columns.*)',
            '_selectedItemsChanged(selectedItems.*)'
          ];
        }

        updateColumns() {
          const probs = ['hidden', 'name', 'frozen', 'width', 'flexGrow', 'path'];
          for (let i = 0; i < this.columns.length; ++i) {
            const prefix = 'columns.' + i + '.';
            probs.forEach(prob => {
              const path = prefix + prob;
              this.notifyPath(path);
            });
          }
        }

        constructor() {
          super();
          this._observer = new Polymer.FlattenedNodesObserver(this, info => {
            this._checkRowDetailsTemplate(info.addedNodes);
          });
        }

        _checkRowDetailsTemplate(nodes) {
          const rowDetailsTemplate = nodes.filter(node => {
            return node.localName && node.localName === 'template' && node.className && node.className.indexOf('row-details') !== -1;
          });
          if (rowDetailsTemplate.length) {
            this._expandableRows = true;
            this._vaadinGrid._rowDetailsTemplate = rowDetailsTemplate[0];

            const templatizer = new Vaadin.Grid.Templatizer();
            templatizer._grid = this._vaadinGrid;
            templatizer.dataHost = this._vaadinGrid.dataHost;
            templatizer.template = this._vaadinGrid._rowDetailsTemplate;
            this._vaadinGrid._rowDetailsTemplate.templatizer = templatizer;
          }
        }

        ready() {
          super.ready();

          this._vaadinGrid = this.shadowRoot.querySelector('vaadin-grid');
          this._vaadinGrid._pxDataGrid = this;
          this._vaadinGrid.addEventListener('px-sorter-changed', this._onPxSorterChanged);

          // Attach scroll listener for styling
          this._boundedScrollListener = this._scrollListener.bind(this);
          this._vaadinGrid.$.outerscroller.addEventListener('scroll', this._boundedScrollListener);

          // Override selectItem method to allow easy single select handling
          this._vaadinGrid.selectItem = (item) => this._handleSelectItem(item);

          // Override getItemId to allow group by
          this._boundedGetItemId = this._gridGetItemId.bind(this);
          this._vaadinGrid.getItemId = this._boundedGetItemId;

          this.addEventListener('column-froze', (event) => this._handleColumnFreeze(event));

          this.addEventListener('column-unfroze', (event) => this._handleColumnUnfreeze(event));

          this.addEventListener('group-by-column', (event) => {
            if (this._groupByColumn) {
              this._ungroup();
            }
            this._moveColumnToLeft(event.detail.column);
            this._groupByColumn = event.detail.column;
            this._vaadinGrid.clearCache();
            this._vaadinGrid.setAttribute('tree-grid', true);
          });

          this.addEventListener('ungroup', (event) => {
            this._ungroup();
          });

          this.addEventListener('item-save', () => {
            if (this._groupByColumn) {
              this._vaadinGrid.clearCache();
            }
          });

          this._boundedCancelEdit = this._cancelEdit.bind(this);
          this._boundedSaveItem = this._saveItem.bind(this);
          this._boundedEditItem = this._setEditingItem.bind(this);

          document.addEventListener('renderer-editing-changed', (event) => {
            const renderer = event.detail.renderer;
            if (renderer._editing) {
              this._editingRenderers.push(renderer);
            } else {
              this._editingRenderers.splice(this._editingRenderers.indexOf(renderer), 1);
            }
          });

          // Safari needs a little help with showing the edit and action buttons on hover.
          if (this._vaadinGrid._safari) {
            const tbodyelement = this._vaadinGrid.$.table.querySelector('#items');
            tbodyelement.addEventListener('mouseover', this._onRowHoverEvent.bind(this));
            tbodyelement.addEventListener('mouseout', this._onRowUnhoverEvent.bind(this));
          }
        }

        _onRowHoverEvent(event) {
          let searchElement = event.target.offsetParent;
          while (searchElement) {
            if (searchElement.tagName && searchElement.tagName.toLowerCase() == 'tr') {
              searchElement.classList.add('safari-hover');
              this.lastColumnWithSafariStyleForHover = searchElement;
              break;
            }
            searchElement = searchElement.offsetParent;
          }
        }

        _onRowUnhoverEvent(event) {
          if (this.lastColumnWithSafariStyleForHover) {
            this.lastColumnWithSafariStyleForHover.classList.remove('safari-hover');
          }
        }

        _ungroup() {
          this._groupByColumn = false;
          this._vaadinGrid.clearCache();
          this._vaadinGrid.removeAttribute('tree-grid');
        }

        _resolveLastFrozenColumnIndex() {
          let lastColumnFrozen = undefined;

          const columns = this._getColumns();

          for (let i = 0; i < columns.length; ++i) {
            if (columns[i].frozen) {
              lastColumnFrozen = i;
            }
          }

          return lastColumnFrozen;
        }

        _columnSanityCheck() {
          const lastColumnFrozen = this._resolveLastFrozenColumnIndex();

          if (lastColumnFrozen !== undefined) {
            const columns = this._getColumns();
            const lastFrozenColumn = columns[lastColumnFrozen];

            if (lastColumnFrozen > 0) {
              for (let i = 0; i < lastColumnFrozen; ++i) {
                if (!columns[i].frozen) {
                  columns[i].frozen = true;
                  if (columns[i].mappedObject) {

                    columns[i].mappedObject.frozen = true;
                  }
                }
              }
            }

            columns.forEach(c => c._lastFrozenChanged(c === lastFrozenColumn));
          }
        }

        // put frozen column to the beginning (in the place of the first data column)
        _handleColumnFreeze(event) {
          const column = event.detail.column;
          this._moveColumnToLeft(column);
        }

        _moveColumnToLeft(column) {
          const columns = this._getColumns();
          const columnId = column.mappedObject ? column.mappedObject.id : undefined;

          if (columnId === undefined) {
            console.warn('Failed to resolve column ID of frozen column');
            return;
          }

          let firstDataColumnIndex = 0;
          for (let i = 0; i < columns.length; i++) {
            if (columns[i].isDataColumn && columns[i] !== this._groupByColumn) {
              firstDataColumnIndex = i;
              break;
            }
          }

          let targetColumnIndex = 0;
          for (let i = 0; i < columns.length; i++) {
            if (columns[i].isDataColumn) {
              const columnObj = columns[i].mappedObject;
              if (columnObj && columnObj.id === columnId) {
                targetColumnIndex = i;
                break;
              }
            }
          }

          this._vaadinGrid.insertBefore(columns[targetColumnIndex], columns[firstDataColumnIndex]);
        }

        _handleColumnUnfreeze(event) {
          const lastFrozen = this._getColumns().filter((column) => column._lastFrozen)[0];
          if (lastFrozen) {
            this._vaadinGrid.insertBefore(event.detail.column, lastFrozen.nextSibling);
          }
        }

        _doInstantSortAfterSelect() {
          return this.instantSortWhenSelection
            && this.allowSortBySelection
            && Array.from(this._vaadinGrid._sorters)
              .map(s => s.path)
              .filter(p => p === '--selection--').length > 0;
        }

        _selectedItemsChanged(selectedItems) {
          // Cause resort if ready and asked to instantly re-sort
          if (this._vaadinGrid && this._doInstantSortAfterSelect()) {
            this._vaadinGrid.clearCache();
          }
        }

        _groupByColumnAllowed(hasLocalDataProvider, expandableRows) {
          return hasLocalDataProvider && !expandableRows;
        }

        /**
         * Trick to prevent multiselection when in single select mode
         */
        _handleSelectItem(item) {
          if (!this._vaadinGrid._isSelected(item)) {
            if (!this._isMultiSelect()) {
              this._vaadinGrid.selectedItems = [];
            }
            this._vaadinGrid.push('selectedItems', item);
          }
        }

        _getValue(column, item) {
          if (column && item) {
            return this.get(column.path, item);
          } else {
            return undefined;
          }
        }

        _getColumnWidth(column) {
          return column.width ? column.width : this.defaultColumnWidth;
        }

        _getColumnFlexGrow(column) {
          return column.flexGrow === undefined ? this.defaultColumnFlexGrow : column.flexGrow;
        }

        _resolveCellColor(item, column) {
          if (!this._highlightEntities || item === undefined) {
            return undefined;
          }

          let columnColor;
          let rowColor;
          let cellColor;

          this._highlightEntities.forEach((highlightEntity) => {
            if (highlightEntity.type === 'row') {
              if (this._isRowConditionApplied(item, highlightEntity.condition)) {
                if (highlightEntity.color) {
                  rowColor = highlightEntity.color;
                } else {
                  rowColor = 'default';
                }
              }
            } else if (highlightEntity.type === 'column') {
              if (this._isColumnConditionApplied(column, highlightEntity.condition)) {
                if (highlightEntity.color) {
                  columnColor = highlightEntity.color;
                } else {
                  columnColor = 'default';
                }
              }
            } else {
              const value = this._getValue(column, item);
              if (highlightEntity.condition(value, column, item)) {
                if (highlightEntity.color) {
                  cellColor = highlightEntity.color;
                } else {
                  cellColor = 'default';
                }
              }
            }
          });

          const finalColor = cellColor ? cellColor : (rowColor ? rowColor : (columnColor ? columnColor : undefined));
          return finalColor;
        }

        _isRowConditionApplied(item, condition) {
          return !!this.columns.filter(column => {
            const cellText = this.get(column.name, item);
            return condition(cellText, item);
          }).length;
        }

        _isColumnConditionApplied(column, condition) {
          const cachedItems = this._vaadinGrid._cache.items;
          const itemsArray = Object.keys(cachedItems).map(key => cachedItems[key]);

          return !!itemsArray.filter(item => {
            return condition(column, item);
          }).length;
        }

        _tableDataChanged(tableData, splices, isAttached) {
          if (!isAttached) {
            return;
          }

          if (tableData) {
            this._currentDataProvider = (params, callback) => {
              this._localDataProvider(params, (items, size) => {
                callback(items, size);
                this._populateTableColumns(items);
              });
            };
            this._hasLocalDataProvider = true;
          }
          this._editingItem = null;
        }

        _compareValues(a, b, path, direction) {
          // Selection is inverted to make selected smaller than not selected
          const valueA = path === '--selection--' ? !this._vaadinGrid._isSelected(a) : Polymer.Base.get(path, a);
          const valueB = path === '--selection--' ? !this._vaadinGrid._isSelected(b) : Polymer.Base.get(path, b);

          if (direction === 'asc') {
            return this._compare(valueA, valueB);
          } else if (direction === 'desc') {
            return this._compare(valueB, valueA);
          } else {
            return 0;
          }
        }

        /**
         * Do not drop item for page sizing here, or it will break things
         */
        _localDataResolver(params, items) {
          if (params.filters) {
            const autoFilters = params.filters.filter(filter => filter.value.isAutoFilter);

            if (autoFilters.length && this._vaadinGrid._checkPaths(autoFilters, 'filtering', items)) {
              items = this._applyAutoFilter(items, autoFilters);
            }

            const advancedFilters = params.filters
              .filter(filter => filter.value.isAdvancedFilter)
              .map(filter => filter.value.filter);

            if (advancedFilters && advancedFilters.length != 0) {
              items = this._applyCustomFilter(items, this.columns, advancedFilters);
            }
          }

          if (params.sortOrders && params.sortOrders.length && this._vaadinGrid._checkPaths(this._sorters, 'sorting', items)) {
            const multiSort = (a, b) => {
              return params.sortOrders.map(sort => {
                if (sort.direction === 'asc' || sort.direction === 'desc') {
                  return this._compareValues(a, b, sort.path, sort.direction);
                } else {
                  return 0;
                }
              }).reduce((p, n) => {
                return p ? p : n;
              }, 0);
            };

            items = items.slice(0).sort(multiSort);
          }

          // Do not apply pageSize slice here, it will break sizing

          return items;
        }

        /**
         * Overridden version of vaadin-grid getItemId, to allow grouping
         * Always use instance compare in case of hasChildren
         */
        _gridGetItemId(item) {
          if (this._groupByColumn && item && item._groupId) {
            return item._groupId;
          } else {
            return this.itemIdPath ? this._vaadinGrid.get(this.itemIdPath, item) : item;
          }
        }

        _localDataProvider(params, callback) {
          let items = (Array.isArray(this.tableData) ? this.tableData : []).slice(0);
          items = this._localDataResolver(params, items);

          if (this._groupByColumn) {
            const columnPath = this._groupByColumn.path;
            if (!params.parentItem) {
              const valuesMap = items.reduce((map, item) => {
                const value = item[columnPath];
                const groupItem = Object.assign({}, item);
                for (const i in groupItem) { // px-data-grid/issues/160
                  if (i !== columnPath) {
                    groupItem[i] = '';
                  }
                }
                if (this._groupByColumn.mappedObject) {
                  groupItem._groupId = '--group--' + this._groupByColumn.mappedObject.id + '-' + value;
                }
                groupItem.hasChildren = true;
                map.set(value, groupItem);
                return map;
              }, new Map());
              items = [];
              valuesMap.forEach((item) => items.push(item));
            } else {
              items = items.filter((item) => item[columnPath] === params.parentItem[columnPath]);
            }
          }

          const totalSize = items.length;

          const start = params.page * params.pageSize;
          const end = start + params.pageSize;
          items = items.slice(start, end);

          callback(items, totalSize);
        }

        /**
         * Will return all local items after filter (no ordering applied)
         */
        _getAllLocalItems() {
          if (this._hasLocalDataProvider) {
            const items = (Array.isArray(this.tableData) ? this.tableData : []).slice(0);
            return this._localDataResolver({
              page: 0,
              pageSize: this.tableData.length
            }, items);
          } else {
            return [];
          }
        }

        _remoteDataProviderChanged(provider) {
          this._hasLocalDataProvider = false;
          this._currentDataProvider = (params, callback) => {
            provider(params, (items, size) => {
              callback(items, size);
              this._populateTableColumns(items);
            });
          };
        }

        _resolveColumnPath(column) {
          if (typeof column.path === 'undefined') {
            console.warn(`column.path for column ${JSON.stringify(column)} should be initialized.`);
          }
          return column.path ? column.path : '';
        }

        _populateTableColumns(data) {
          if (!this.columns.length && data && data.length) {
            this.columns = [];
            for (const key in data[0]) {
              this.push('columns', {
                name: key,
                hidden: false,
                editable: true,
                renderer: 'px-data-grid-string-renderer',
                type: 'string',
                path: key,
                generated: true
              });
            }
          }

          this._updateActionMenu();
        }

        /**
         * Event handler for action menu clicks
         */
        _actionClicked(evt) {
          const item = evt.detail.detail.item;
          const key = item.key;

          if (key && typeof key == 'string') {
            // -column- is temporary work around to limitations of px-dropdown
            if (key.indexOf('-column-') === 0) {
              const columnId = key.substr('-column-'.length);
              const column = this._getColumnElementById(columnId);
              if (column) {
                column.hidden = column.hidden === undefined ? true : !column.hidden;
              } else {
                console.warn('Failed to find column with ID ' + columnId);
              }
            } else if (key.indexOf('-action-') === 0) {
              const actionId = key.substr('-action-'.length);
              this.dispatchEvent(new CustomEvent('table-action', {
                detail: {
                  id: actionId
                },
                composed: true,
                bubbles: true
              }));
            } else if (key.indexOf('-internal-ungroup-') === 0) {
              this._ungroup();
            }
          }
        }

        /**
         * Function to resolve (data) columns on grid
         */
        _getColumns() {
          return this._vaadinGrid ? Array.from(this._vaadinGrid.querySelectorAll('px-data-grid-column')) : [];
        }

        /**
         * Function called when action menu content needs to be updated
         */
        _updateActionMenu() {
          const content = [];
          this._selectedActionItems = [];

          // Application specific options

          if (this.tableActions) {
            this.tableActions.forEach((item) => {
              content.push({
                key: '-action-' + item.id,
                val: item.name,
                selected: false,
                disableSelect: true
              });
            });
          }

          if (this._groupByColumn) {
            content.push({
              key: '-internal-ungroup-',
              val: this.localize('Clear Grouping'),
              selected: false,
              disableSelect: true
            });
          }

          // Add column hide/show selection

          const defaultName = this.localize('Column #');
          let counter = 0;
          const selected = [];
          // Allow 0, as that happens if this gets called before columns are ready
          const oneVisibleColumn = this.getVisibleColumns().length == 1;

          this._getColumns().forEach((columnElement) => {
            const columnId = columnElement.mappedObject ? columnElement.mappedObject.id : undefined;
            // If this method gets called before column IDs are generated,
            // just ignore those columns.
            if (columnId === undefined) {
              return;
            }

            const index = ++counter;
            const hidden = columnElement.hidden ? columnElement.hidden : false;
            const name = columnElement.name ? columnElement.name : (defaultName + index);
            // -column- is temporary work around to limitations of px-dropdown
            const key = '-column-' + columnId;
            const groupedByThis = this._groupByColumn === columnElement;

            const item = {
              key: key,
              val: name,
              disabled: groupedByThis || (oneVisibleColumn && !hidden)
            };

            if (!hidden) {
              selected.push(key);
            }

            content.push(item);
          });

          this._actionMenuContent = content;
          this._selectedActionItems = selected;
        }

        _getColumnsWithName(name) {
          return this._getColumns().filter(c => c.name == name);
        }

        _getColumnById(columnId) {
          return this.columns.filter((column) => column.id === columnId)[0];
        }

        _getColumnElementById(columnId) {
          return this._getColumns()
            .filter(column => column.mappedObject && column.mappedObject.id == columnId)[0];
        }

        _scheduleColumnSanityCheck() {
          this._columnSanityCheckDebouncer = Polymer.Debouncer.debounce(
            this._columnSanityCheckDebouncer,
            Polymer.Async.idlePeriod,
            () => {
              this._columnSanityCheck();
            }
          );
        }

        _onColumnUpdate(event) {
          if (event.detail.type == 'hidden') {
            this._updateActionMenu();
          } else if (event.detail.type == 'frozen') {
            this._scheduleColumnSanityCheck();
          }
        }

        _loadingChanged(loading) {
          clearTimeout(this._spinnerHiddenTimeout);

          if (loading) {
            this._spinnerHiddenTimeout = setTimeout(() => this._spinnerHidden = false, this.loadingSpinnerDebounce);
          } else {
            this._spinnerHidden = true;
          }
        }

        /**
         * Simple method to check if action bar should be shown
         */
        _showActionBar(filterField, hideActionMenu, filterable) {
          return filterField || !hideActionMenu || filterable;
        }

        /**
         * Helper method to check if header is defined, if not use name
         */
        resolveColumnHeader(column) {
          return column.header ? column.header : column.name;
        }

        /**
         * This to be moved to inner data-provider when we get that done. Until then
         * this will add workaround that allows to filter inmemory data given via
         * items parameter.
         */
        _applyAutoFilter(items, filters) {
          return items.filter((item, index) => {
            return filters.filter(filter => {
              const filterValueLowercase = this._vaadinGrid._normalizeEmptyValue(filter.value.query).toString().toLowerCase();
              if (item && filter.path === undefined) {
                for (const key in item) {
                  const value = this._vaadinGrid._normalizeEmptyValue(Polymer.Base.get(key, item));
                  if (value.toString().toLowerCase().indexOf(filterValueLowercase) !== -1) {
                    return false;
                  }
                }
                return true;
              } else {
                const value = this._vaadinGrid._normalizeEmptyValue(Polymer.Base.get(filter.path, item));
                return value.toString().toLowerCase().indexOf(filterValueLowercase) === -1;
              }
            }).length === 0;
          });
        }

        /**
         * Listener for auto filter component
         */
        _autoFilterChanged(event) {
          // Ignore if autofiltering not enabled
          if (!this.autoFilter) {
            return;
          } else {
            const filters = this._vaadinGrid._filters
              .filter(filter => !filter.value.isAutoFilter);

            filters.push({
              value: {
                query: event.detail.value,
                isAutoFilter: true
              }
            });

            this._vaadinGrid._filters = filters;
            this._vaadinGrid.clearCache();
          }
        }

        _isGroupedByColumn(column, _groupByColumn) {
          return _groupByColumn && _groupByColumn.name === column.name;
        }

        /**
         * Method forcing column order rules. To be run after any column order change
         */
        _columnOrderCleaner() {
          const columnsRow = this._getColumns();
          const leftColumns = columnsRow.filter(c => !c.isDataColumn && c.frozen);
          const rightColumns = columnsRow.filter(c => c.isDataColumn || !c.frozen);

          if (leftColumns && leftColumns.length && rightColumns && rightColumns.length) {
            const firstRight = rightColumns[0];
            leftColumns.forEach(c => {
              this._vaadinGrid.insertBefore(c, firstRight);
            });
          }
        }

        /**
         * Check if selections are allowed
         */
        _isSelectable() {
          return this.selectionMode == 'single' || this.selectionMode == 'multi';
        }

        /**
         * Check if grid is in multi selection mode
         */
        _isMultiSelect() {
          return this._isSelectable() && this.selectionMode == 'multi';
        }

        _selectionModeChanged(mode) {
          if (mode != 'none' && mode != 'single' && mode != 'multi') {
            console.warn('Invalid selection-mode value \'' + mode + '\', use \'none\', \'single\' or \'multi\'');
            return;
          }

          const selectable = mode != 'none';

          // clear selections if mode is 'none'
          if (mode === 'none' && this._vaadinGrid) {
            this._vaadinGrid.selectedItems = [];
          }

          // clear selections if mode is 'single' and there are more than 1 selected items
          if (mode === 'single' && this._vaadinGrid && this._vaadinGrid.selectedItems.length > 1) {
            this._vaadinGrid.selectedItems = [];
          }

          if (selectable) {
            setTimeout(() => {
              if (this.selectable) {
                this._columnOrderCleaner();
              }
            });
          }

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
        }

        _highlightsObserver(highlight, filterHighlights) {
          this.set('_highlightEntities', highlight.concat(filterHighlights));
        }

        _gridHeightChanged(gridHeight) {
          if (!this._vaadinGrid) {
            return;
          }

          // In case of real undefined (or 'default' string, for demo cases)
          // and 'auto' the CSS height of vaadin-grid is set to undefined. Other
          // values are set as CSS height value to vaadin-grid.
          if (!this.gridHeight || this.gridHeight == 'default' || this.gridHeight == 'auto') {
            this._vaadinGrid.style.height = null;
          } else {
            this._vaadinGrid.style.height = this.gridHeight;
          }

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
        }

        _onRowDetailsChange(rowDetails) {
          if (this._vaadinGrid && !rowDetails) {
            this._vaadinGrid.detailsOpenedItems = [];
          }
        }

        /**
         * Set visibility of the details container for any item's corresponding row.
         */
        setRowDetailsVisible(item, isVisible) {
          if (!item) {
            return;
          }
          const index = this._vaadinGrid.detailsOpenedItems.indexOf(item);
          if (isVisible && index < 0) {
            this._vaadinGrid.detailsOpenedItems.push(item);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          } else if (!isVisible && index >= 0) {
            this._vaadinGrid.detailsOpenedItems.splice(index, 1);
            Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._vaadinGrid.notifyResize());
          }
        }

        _editingItemObserver(editingItem, oldV) {
          if (typeof oldV === 'undefined') {
            return;
          }

          this.dispatchEvent(new CustomEvent('editing-item-changed', {
            bubbles: true,
            composed: true,
            detail: {
              item: editingItem
            }
          }));
        }

        _setEditingItem(event) {
          // To prevent selections
          event.stopPropagation();
          this._editingItem = event.details.item;

          // To refresh row height after edit...
          this._vaadinGrid.notifyResize();
        }

        _cancelEdit(event) {
          this._editingRenderers.forEach((renderer) => renderer.restoreInitial());
          this._editingItem = null;
          // To refresh row height after edit...
          this._vaadinGrid.notifyResize();
        }

        _isItemEditing(item, editingItem) {
          return item === editingItem;
        }

        _isAnyItemEditing(editingItem) {
          return !!editingItem;
        }

        _saveItem() {
          if (this._editingRenderers.every((renderer) => renderer._performValidation().valid)) {
            const changedPaths = this._editingRenderers
              .filter((renderer) => renderer.applyValue())
              .map((renderer) => renderer.column.path);

            if (changedPaths.length > 0) {
              this.dispatchEvent(new CustomEvent('item-edited',
                {
                  bubbles: true,
                  composed: true,
                  detail: {
                    item: this._editingItem,
                    paths: changedPaths
                  }
                }
              ));
            }

            this._editingItem = null;
            // To refresh row height after edit...
            this._vaadinGrid.notifyResize();
          }
        }

        _localizeChanged(localize) {
          this._boundedLocalize = localize.bind(this);
        }

        _scrollListener(e) {
          if (e.target.scrollLeft != 0) {
            this._vaadinGrid.setAttribute('horizontal-offset', 'true');
          } else {
            this._vaadinGrid.removeAttribute('horizontal-offset');
          }
        }

        /**
         * Overridden version of _onSorterChanged in vaadin-grid-sort-mixin. Is mapped to custom event
         * px-sorter-changed emitted by px-data-grid-sorter. Only difference is to use push, not
         * unshift, when adding sort rule to _sorters. If errors in this method, update to match with
         * current version in vaadin-grid-sort-mixin, and replace unshift with push.
         */
        _onPxSorterChanged(e) {

          this._pxDataGrid._editingItem = null;

          const sorter = e.detail.sorter;

          this._removeArrayItem(this._sorters, sorter);
          sorter._order = null;

          if (this.multiSort) {
            if (sorter.direction) {
              this._sorters.push(sorter);
            }

            this._sorters.forEach((sorter, index) => sorter._order = this._sorters.length > 1 ? index : null, this);
          } else {
            this._sorters.forEach(sorter => {
              sorter._order = null;
              sorter.direction = null;
            });

            if (sorter.direction) {
              this._sorters = [sorter];
            }
          }

          e.stopPropagation();

          if (this.dataProvider &&
            // No need to clear cache if sorters didn't change
            JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
            this.clearCache();
          }

          this._a11yUpdateSorters();

          this._previousSorters = this._mapSorters();
        }

        /**
         * Get current visible columns in grid
         */
        getVisibleColumns() {
          return this._getColumns().filter((col) => !col.hidden).sort((a, b) => a._order - b._order);
        }

        /**
         * Returns currently visible data if `true` parameter is passed or all cached data if no parameter is passed.
         */
        getData(visibleOnly) {
          let items = [];

          if (visibleOnly) {
            items = Array.from(this._vaadinGrid.querySelectorAll('px-data-grid-cell-content-wrapper'));

            const gridRect = this._vaadinGrid.getBoundingClientRect();
            const headerRect = this._vaadinGrid
              .querySelector('px-data-grid-header-cell')
              .getBoundingClientRect();

            items = items.filter((wrapper) => {
              const wrapperRect = wrapper.getBoundingClientRect();
              return wrapperRect.top < gridRect.bottom && wrapperRect.bottom > headerRect.bottom;
            }).map((wrapper) => {
              return wrapper.item;
            }).filter((v, i, a) => {
              return a.indexOf(v) === i && v;
            });
          } else {
            const cachedItems = this._vaadinGrid._cache.items;
            Object.keys(cachedItems).forEach((key) => {
              items.push(cachedItems[key]);
            });
          }

          return items.map((item) => {
            const sortedObject = {};

            this.getVisibleColumns().forEach((col) => {
              sortedObject[col.path] = item[col.path];
            });

            return sortedObject;
          });
        }

        /**
         * Make JSON friendly version out of columns array
         */
        _cleanColumns(columns) {
          if (!columns) {
            return [];
          }
          return this._copyArray(columns);
        }

        /**
         * Columns property change observer
         */
        _columnsChanged(columns) {
          // Store cleaned version of current columns
          this._lastColumnsReceived = this._cleanColumns(columns);
          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this._updateActionMenu());
        }

        _setColumnId(columns) {
          if (!columns || this._columnIdSetting) {
            return;
          }

          this._columnIdSetting = true;
          columns.forEach((column, index) => {
            if (!column.id) {
              this.set(`columns.${index}.id`, `${column.path}[${column.type || 'string'}]`);

              if (columns.filter((col) => col.id === column.id).length > 1) {
                console.warn(`Warning! There are multiple columns with '${column.path}' path ` +
                  `and '${column.type || 'string'}' type, please provide column.id for those columns`);
              }
            }
          });
          this._columnIdSetting = false;
        }

        /**
         * Restore layout (columns) to state those were given
         */
        restoreLayout() {
          if (!this._lastColumnsReceived) {
            console.warn('No layout defined where to return');
            return;
          }
          // Store last columns received before clearing columns
          const revertTo = this._lastColumnsReceived;
          this._revertColumns(revertTo);
        }

        _revertColumns(revertTo) {
          // First clear all columns
          this.columns = [];

          // After empty columns has been rendered return to wanted state
          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => this.columns = revertTo);
        }

        /**
         * Just to make sure only true or false is given (undefined converted to false).
         * In some cases undefined value breaks functionality,
         */
        _undefinedToFalse(value) {
          if (value === undefined) {
            return false;
          } else {
            return value;
          }
        }

        _copyArray(arr) {
          return JSON.parse(JSON.stringify(arr));
        }

        _isAutoHeight(gridHeight) {
          return gridHeight === 'auto';
        }

        _checkColumnResizable(gridResizable, columnResizable) {
          return gridResizable ? (columnResizable === undefined ? true : columnResizable) : false;
        }

        _isStriped(striped, groupByColumn) {
          return striped && !groupByColumn;
        }

        _ellipsisModeChanged(ellipsisMode) {
          if (ellipsisMode) {
            this.classList.add('ellipsis');
          } else {
            this.classList.remove('ellipsis');
          }
          if (this._vaadinGrid) {
            this._vaadinGrid.notifyResize();
          }
        }

        /**
         * Rewrite of _compare from vaadin-grid to allow incasesensitive compare
         */
        _compare(a, b) {
          a = this._vaadinGrid._normalizeEmptyValue(a);
          b = this._vaadinGrid._normalizeEmptyValue(b);

          // If both are string, make sure values are compared incasesensitive
          // TODO localCompare would be better option, but not sure it's
          // fully supported, and what locale to use
          if (typeof a === 'string' && typeof b === 'string') {
            a = a.toUpperCase();
            b = b.toUpperCase();
          }

          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        }

        _offerEditColumn(editable) {
          return editable;
        }

        _offerActionColumn(editable, itemActions, editingItem) {

          return (editable) || (itemActions && itemActions.length > 0);
        }

        _isColumnReorderingAllowed(columnReordingAllowed, groupByColumn) {
          return columnReordingAllowed && !groupByColumn;
        }

        _openAdvancedFilter(event) {
          this.shadowRoot.querySelector('px-data-grid-filters-modal').open();
        }

        getState() {
          return {
            columns: this.getVisibleColumns(),
            highlight: this.highlight.map(entity => Object.assign({}, entity)),
            filters: this._copyArray(this._filters),
            autoFilter: this._autoFilterValue
          };
        }

        setState(state) {
          this.columns = [];

          Polymer.RenderStatus.afterNextRender(this._vaadinGrid, () => {
            this.columns = state.columns;

            this._filters = state.filters;
            this._autoFilterValue = state.autoFilter;
            this.highlight = state.highlight;
          });
        }
      }
      customElements.define(DataGridElement.is, DataGridElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridElement = DataGridElement;
    }
  </script>
</dom-module>
